use Getopt::Long qw(GetOptions);
use Scalar::Util qw(looks_like_number);
Getopt::Long::Configure qw(gnu_getopt);
use POSIX;

#use diagnostics;


## -------------- HELP ------------- ##


if (@ARGV < 4){
die "\nUSAGE: perl $0 [options] -x <bt-idx>  {-i <Input>}\n
		Options

		-i		Input file with the rute of FASTQ data
		-t		Number of threads 					(Default: 1).
		--Trimmo	Options of Trimmomatic.					(Default: 5:5:4:30:16)
		--bt		Options of Bowtie. 					(Default: 1:10)
		--strand	Strand specific data.					(Default: no)
		--rm		Remove (or not)	intermediary files.			(Default: 1:1:1:1)
		--cr		Cutoff of reads for sRNAs assembled.			(Default: 5)
		--RE		Modify the sRNA ID generated by SHORTCAT		(Default: yes)
				in the matrix generated after cutoff.
		--ANNOT		Perform (or not) annotation of sRNAs.			(Default: no)
		-g		Words used for determine adapters on FASTQ files	(Default: primer,adapter)
				Note: Don't difference uppercase and lowercase.

			Note that the -annot option, in case of select 'yes', requires additional configuration. These are:
				-1		File of annotation. Must be GFF.
				-2		File 2 of annotation. Must be GFF. 			(optional)
				-f		Overlapping of sRNAs with GFF features	.		(Default: 0.50, i.e. 50%)
				-r		Fraction overlap must be reciprocal (sRNAs - GFF).	(optional)
				--strand	Strand specific annotation (yes|not).			(Default: no)

For additional information, please read the manual available in XXXXX.\n\n";	
}


## -------------- PRINT command used ------------- ##

print "\nCommand line used: perl $0 @ARGV\n";



	## ********************************************** PART 1 ********************************************** ##


## -------------- RUTE SCRIPTS IN BIN FOLDER ------------- ##

my $adapters_recov = "bin/1_Adapters.pl";
my $filter_count = "bin/3_filter_count.pl";
my $parse_inter = "bin/4_annot.pl";
my $modify_R = "bin/5_modifiying_R.pl";
my $merge_list = "bin/z_merge_list.pl";
my $parse_annot = "bin/4b_parse.pl";


	## ********************************************** PART 2 ********************************************** ##


## -------------- MAKING FOLDERS ------------- ##
system "mkdir -p 00-quallity/00-raw_data\n";
system "mkdir -p 01-trimming/00-reports\n";
system "mkdir -p 02-mapping/00-reports\n";
system "mkdir -p 03-shortcat/00-reports\n";
system "mkdir -p 04-annotation/00-reports\n";
system "mkdir -p 05-DiffExpression/00-reports\n";
system "mkdir -p 06-FinalTables/\n";


	## ********************************************** PART 3 ********************************************** ##


## -------------- OPTIONS ------------- ##

my $threads = 1;
my $trimmo = "5:5:4:30:16";
my $bowtie = "1:10";
my $remove = "1:1:1:1";
my $cutoff_reads = 5;
my $annot_perform = "no";
my $the_f_option = "0.50";
my $strings_fastqc = "primer,adapter";
my $renamed = "yes";
my $the_s_option = "no";

my $indexBT;
my $gff_annot_1;
my $gff_annot_2;
my $the_r_option;
my $input_file;


GetOptions(
	't=i' => \$threads,
	'Trimmo=s' => \$trimmo,
	'bt=s' => \$bowtie,
	'x=s' => \$indexBT,
	'rm=s' => \$remove,
	'cr=i' => \$cutoff_reads,
	'ANNOT=s' => \$annot_perform,
	'1=s' => \$gff_annot_1,
	'2=s' => \$gff_annot_2,
	'f=s' => \$the_f_option,
	'reciprocal|r' => \$the_r_option,
	'i=s' => \$input_file,
	'g=s' => \$strings_fastqc,
	'RE=s' => \$renamed,
	'strand=s' => \$the_s_option,

) or die "Not valid option(s) found!\n";




## -------------- MODIFIYING OPTIONS ------------- ##

## ---------------------- TRIMMO options (Default: 5:5:4:30:16)
my @sep_trimmo_options = split (/\:/, $trimmo);

my $lg = $sep_trimmo_options[0];
my $tg = $sep_trimmo_options[1];
my $sw_1 = $sep_trimmo_options[2];
my $sw_2 = $sep_trimmo_options[3];
my $ml = $sep_trimmo_options[4];

	## -- 1
if (looks_like_number($lg) != 1){
	print "\t\tOption not selectable for --Trimmo (position HERE:x:x:x:x). Selected '5'.\n";
	$lg = 5;
}

	## -- 2
if (looks_like_number($tg) != 1){
	print "\t\tOption not selectable for --Trimmo (position x:HERE:x:x:x). Selected '5'.\n";
	$tg = 5;
}

	## -- 3
if (looks_like_number($sw_1) != 1){
	print "\t\tOption not selectable for --Trimmo (position x:x:HERE:x:x). Selected '4'.\n";
	$sw_1 = 4;
}

	## -- 4
if (looks_like_number($sw_2) != 1){
	print "\t\tOption not selectable for --Trimmo (position x:x:x:HERE:x). Selected '30'.\n";
	$sw_2 = 30;
}

	## -- 5
if (looks_like_number($ml) != 1){
	print "\t\tOption not selectable for --Trimmo (position x:x:x:x:HERE). Selected '16'.\n";
	$ml = 16;
}




## ---------------------- BOWTIE options (Default: 1:10)
my @sep_bowtie2_options = split (/\:/, $bowtie);

my $mismatch = $sep_bowtie2_options[0];
my $max_N_alig = $sep_bowtie2_options[1];

	## -- 1
if (looks_like_number($mismatch) != 1){
	print "\t\tOption not selectable for --bt (position HERE:x). Selected '1'.\n";
	$mismatch = 1;
}

	## -- 2
if (looks_like_number($max_N_alig) != 1){
	print "\t\tOption not selectable for --bt (position x:HERE). Selected '10'.\n";
	$max_N_alig = 10;
}




## ---------------------- Remove options (Default: 1:1:1:1)

my @sep_rm_option = split (/\:/, $remove);

my $rm_shorcat = $sep_rm_option[0];
my $rm_fastqc = $sep_rm_option[1];
my $rm_clean_data = $sep_rm_option[2];
my $rm_mapped_data = $sep_rm_option[3];

	## -- 1
if (looks_like_number($rm_shorcat) != 1){
	print "\t\tOption not selectable for --rm (in HERE:x:x:x). Selected '1'.\n";
	$rm_shorcat = 1;
} elsif ($rm_shorcat !~ /1|0/){
	print "\t\tOption not selectable for --rm (in HERE:x:x:x). You can select '0' or '1'. Selected '1'.\n";
	$rm_shorcat = 1;
}

	## -- 2
if (looks_like_number($rm_fastqc) != 1){
	print "\t\tOption not selectable for --rm (in x:HERE:x:x). Selected '1'.\n";
	$rm_fastqc = 1;
} elsif ($rm_fastqc !~ /1|0/){
	print "\t\tOption not selectable for --rm (in x:HERE:x:x). You can select '0' or '1'. Selected '1'.\n";
	$rm_fastqc = 1;
}

	## -- 3
if (looks_like_number($rm_clean_data) != 1){
	print "\t\tOption not selectable for --rm (in x:x:HERE:x). Selected '1'.\n";
	$rm_clean_data = 1;
} elsif ($rm_clean_data !~ /1|0/){
	print "\t\tOption not selectable for --rm (in x:x:HERE:x). You can select '0' or '1'. Selected '1'.\n";
	$rm_clean_data = 1;
}

	## -- 4
if (looks_like_number($rm_mapped_data) != 1){
	print "\t\tOption not selectable for --rm (in x:x:x:HERE). Selected '1'.\n";
	$rm_mapped_data = 1;
} elsif ($rm_mapped_data !~ /1|0/){
	print "\t\tOption not selectable for --rm (in x:x:x:HERE). You can select '0' or '1'. Selected '1'.\n";
	$rm_mapped_data = 1;
}




## ---------------------- Annotation (Default: no)
if ($annot_perform !~ /yes|no/){
	print "\t\tOption not valid for --annot. Selected 'no'.\n";
	$annot_perform = "no";
}




## ---------------------- The F option (Default: 0.50)
if (looks_like_number($the_f_option) != 1){
	print "\t\tOption not selectable for -f. Selected '0.50'.\n";
	$the_f_option = 0.50;
} elsif ($the_f_option > 1.0 || $the_f_option <= 0){
	print "\t\tOption not selectable for -f. Muste be <= 1.0 and > 0.0 values. Selected '0.50'.\n";
	$the_f_option = 0.50;
}



## ---------------------- RENAMED options (Default: yes)
if ($renamed !~ /yes|no/){
	print "\t\tOption not valid for --RE. Selected 'yes'.\n";
	$renamed = "yes";
}


## ---------------------- STRAND options (Default: no)
if ($the_s_option !~ /yes|no/){
	print "\t\tOption not valid for --strand. Selected 'no'.\n";
	$the_s_option = "no";
}









## -------------------------------------------------------------CODE---------------------------------------------------------------- ##










	## ********************************************** PART X ********************************************** ##

## -------------- RECOVER RUTE RAW DATA ------------- ##
my @rute_files = `cut -f 1 $input_file`;
chomp @rute_files;




#		##----------------------- Step 1: Quallity analysis: FASTQC and Adapter FASTA creation -----------------------##




print "\n";
print "Step 1 - Quaillity of sequencing data.\n"; # HERE A PRINT OF STEP




## -------------- MAKING FASTQC ------------- ##
	## (files are save on "00-quallity/00-raw_data" create in PART 2)

my $all_fastq_files = join (" ", @rute_files);

system "fastqc -t $threads -q -o 00-quallity/00-raw_data $all_fastq_files\n";	## <- REMOVE COMMENT


## -------------- Over-represented sequences ------------- ##
	## (FASTA file of adapters is save on "00-quallity/" create in PART 2)
	## The words for grep are modifiying

$strings_fastqc =~ s/\,/\\\|/g;

system "cat 00-quallity/00-raw_data/*.html | perl $adapters_recov - | grep -i '$strings_fastqc' | cut -f 1 | sort -u | awk '{print \">adapter_\" NR \"\\n\" \$1}' | cat - bin/z_adapters_truseq.fasta | awk 'NF >= 1' > 00-quallity/z_adapters_sequencing.fasta\n"; ## <- REMOVE COMMENT




		##----------------------- Step 2: Trimming: Trimmomatic performing -----------------------##




print "Step 2 - Trimming process.\n"; # HERE A PRINT OF STEP




## -------------- PREPARING FOR TRIMMOMATIC ------------- ##

foreach my $each_rute (@rute_files){

	my $name_file = `ls $each_rute | awk -F "/" '{print \$NF}'`;
	chomp $name_file;

	my ($name_part1, $name_part2) = split (/\./, $name_file);


	## -------------- MAKING TRIMMOMATIC ------------- ##
		## (files are save on "01-trimming" and reports in "01-trimming/00-reports" creates in PART 2)

#	print "\t\t\n\tThe command used will be:\n\t\ttrimmomatic SE -threads $threads -phred33 $each_rute 01-trimming/$name_part1\_good.fastq ILLUMINACLIP:00-quallity/z_adapters_sequencing.fasta:2:30:10 LEADING:$lg TRAILING:$tg SLIDINGWINDOW:$sw_1:$sw_2 MINLEN:$ml\n\n"; ## <- VER SI ELIMINAR 

	system "trimmomatic SE -threads $threads -phred33 $each_rute 01-trimming/$name_part1\_good.fastq ILLUMINACLIP:00-quallity/z_adapters_sequencing.fasta:2:30:10 LEADING:$lg TRAILING:$tg SLIDINGWINDOW:$sw_1:$sw_2 MINLEN:$ml 2> TRIMMO_REPORT.txt"; ## <- REMOVE COMMENT

	#- REPORTS -#

	my $report_trimmo = `grep "Input Reads: " TRIMMO_REPORT.txt`;
	chomp $report_trimmo;

	$report_trimmo =~ s/input reads: //gi;
	$report_trimmo =~ s/ dropped: | surviving: |\(|\)/ /gi;
	
	my @div_report_trimmo = split (" ", $report_trimmo);

	my $input_reads = $div_report_trimmo[0];
	my $surviving = $div_report_trimmo[1];
	my $percent_surv = $div_report_trimmo[2];
	my $dropped = $div_report_trimmo[3];
	my $percent_drop = $div_report_trimmo[4];

	open ($fh_1,">","01-trimming/00-reports/$name_part1\_Trimmomatic.report");

	print $fh_1 "Total Reads as INPUT:\t$input_reads\nTotal Reads Survived:\t$surviving ($percent_surv)\nTotal Dropped:\t$dropped ($percent_drop)\n";

	system "rm TRIMMO_REPORT.txt"; ##<- REMOVE COMMENT

	close ($fh_1);
}




		##----------------------- Step 3: Mapping: Bowtie performing -----------------------##



print "Step 3 - Mapping process\n"; # HERE A PRINT OF STEP




## -------------- RECOVER RUTE CLEAN DATA ------------- ##

my @fastq_good_files = `ls 01-trimming/*_good.fastq`;
chomp @fastq_good_files;

foreach my $each_fastq_good (@fastq_good_files){

	my $name_fastq_good = `ls $each_fastq_good | awk -F "/" '{print \$NF}'`;
	chomp $name_fastq_good;

	my ($name_good_part1, $name_good_part2) = split (/\./, $name_fastq_good);


	## -------------- MAKING BOWTIE ------------- ##
		## (files are save on "02-mapping" and reports in "02-mapping/00-reports" creates in PART 2)

#	print "\t\t\n\tThe command used will be:\n\t\tbowtie -p $threads --mm -n $mismatch --best --strata -m $max_N_alig $indexBT -q $each_fastq_good -S 02-mapping/$name_good_part1\_$mismatch\_m$max_N_alig\.sam\n\n"; ## <- VER SI ELIMINAR

	system "bowtie -p $threads --mm -n $mismatch --best --strata -m $max_N_alig $indexBT -q $each_fastq_good -S 02-mapping/$name_good_part1\_$mismatch\_m$max_N_alig\.sam 2> BOWTIE_REPORT.txt\n"; ##<- REMOVE COMMENT

	
	#- REPORTS -#

	my @report_bt = `cat BOWTIE_REPORT.txt`;
	chomp @report_bt;

	open ($fh_2,">","02-mapping/00-reports/$name_good_part1\_$mismatch\_m$max_N_alig\.bt");

	foreach my $each_line_report_bt (@report_bt){
	
		if ($each_line_report_bt =~ /reads processed/){
			$each_line_report_bt =~ s/# reads processed: //g;
			print $fh_2 "Total Reads used as input:\t$each_line_report_bt\n";
		}

		if ($each_line_report_bt =~ /reads with at least one/){
			$each_line_report_bt =~ s/# reads with at least one reported alignment: //g;
			print $fh_2 "Total Reads with >= 1 aligment:\t$each_line_report_bt\n";
		}

		if ($each_line_report_bt =~ /reads that failed to/){
			$each_line_report_bt =~ s/# reads that failed to align: //g;
			print $fh_2 "Total Reads unaligned:\t$each_line_report_bt\n";
		}

		if ($each_line_report_bt =~ /reads with alignments suppressed/){
			$each_line_report_bt =~ s/# reads with alignments suppressed due to -m: //g;
			print $fh_2 "Total Reads suppresed with -m option:\t$each_line_report_bt\n";
		}
	}

	close ($fh_2);

	system "rm BOWTIE_REPORT.txt"; ## <- REMOVE COMMENT
}




		##----------------------- Step 4: Assembly: Shortcat performing -----------------------##




print "Step 4 - SHORTCAT\n"; # HERE A PRINT OF STEP




## -------------- RECOVER INDEXES FOR SHORCAT ------------- ##

my @files_and_prefixes = `cat $input_file`;
chomp @files_and_prefixes;

foreach my $each_file_and_prefix (@files_and_prefixes){

	my ($rute_file_2, $prefix) = split ("\t", $each_file_and_prefix);

	my $name_file_2_raw = `ls $rute_file_2 | awk -F "/" '{print \$NF}'`;
	chomp $name_file_2_raw;

	my ($name_file_2_raw2, $rest_2) = split (/\./, $name_file_2_raw);

	my $name_file_2 = $name_file_2_raw2 . "\_good\_$mismatch\_m$max_N_alig\.sam";

	my $name_out = $name_file_2;
	$name_out =~ s/\.sam//g;


	## -------------- GENERATING MODIFIED SAM FILES ------------- ##
		## (files are save on "03-shortcat" create in PART 2)

	system "grep -v \"@\" 02-mapping/$name_file_2 | cut -f2-14 | awk '{print \"$prefix\_\"NR\"\\t\"\$LINE}' > 03-shortcat/$name_out\_modified.sam\n"; ## <- REMOVE COMMENT

}


## -------------- GENERATING CONCATENATED SAM ------------- ##

system "cat 03-shortcat/*_modified.sam > 03-shortcat/all.reads.sam\n"; ##<- REMOVE COMMENT
system "rm 03-shortcat/*_modified.sam\n"; ##<- REMOVE COMMENT


# -------------- MAKING SHORTCAT ------------- ##

$the_indexes = `cut -f 2 $input_file | awk '{printf \$1 ","} END {print "x"}' | sed 's/\\,x//g'`;
chomp $the_indexes;

# print "\nAssembly ready to procced.\n\t\t\n\tThe command used will be:\n\t\tperl bin/2_shortCat.pl -i 03-shortcat/all.reads.sam -c $the_indexes\n\n"; ## <- VER SI ELIMINAR

system "perl bin/2_shortCat.pl --strand $the_s_option -i 03-shortcat/all.reads.sam -c $the_indexes\n"; ##<- REMOVE COMMENT


# -------------- REMOVING INTERMEDIRE SHORTCAT FILES ------------- ##

if ($rm_shorcat =~ /1/){ 				##<- REMOVE COMMENT
	system "rm 03-shortcat/all.bed";		##<- REMOVE COMMENT
	system "rm 03-shortcat/all_merge.bed";		##<- REMOVE COMMENT
	system "rm 03-shortcat/all.reads.sam";		##<- REMOVE COMMENT
}							##<- REMOVE COMMENT


# -------------- REPORTS ------------- ##

my $number_sRNAs = `wc -l 03-shortcat/all.count | cut -f 1 | awk '{print \$1 - 1}'`;
chomp $number_sRNAs;

my $min_length_sRNAs = `cut -f 5 03-shortcat/all.count | awk 'NR > 1' | sort -n | head -1`;
chomp $min_length_sRNAs;

my $max_length_sRNAs = `cut -f 5 03-shortcat/all.count | awk 'NR > 1' | sort -n | tail -1`;
chomp $max_length_sRNAs;

my $number_of_one_read = `cut -f 7 03-shortcat/all.count | awk 'NR > 1' | sort -n | uniq -c | awk '{if(\$2 == 1) print \$1}'`;
chomp $number_of_one_read;

my $percent_of_one_read = "0%";

if (defined $number_of_one_read){
	$percent_of_one_read = ceil (($number_of_one_read * 100)/$number_sRNAs);  # Here is the use of module (ceil from POSIX)
} else {
	$number_of_one_read = 0;
}

open ($fh_3,">","03-shortcat/00-reports/z_shortcat_report.txt");

print $fh_3 "Total sRNAs assembled:\t$number_sRNAs\n";
print $fh_3 "Considering Counts from all samples:\n\t$number_of_one_read sRNAs were formed by only 1 Read ($percent_of_one_read\%)\n";
print $fh_3 "The length of sRNAs varies between $min_length_sRNAs - $max_length_sRNAs\n";




		##----------------------- Step 5: Removing files (optional) -----------------------##




print "Step 5 - Removing files\n"; # HERE A PRINT OF STEP




# -------------- REMOVE FASTQC FILES ------------- ##

if ($rm_fastqc =~ /1/){						##<- REMOVE COMMENT
	system "rm 00-quallity/00-raw_data/*.zip\n";		##<- REMOVE COMMENT
}								##<- REMOVE COMMENT


# -------------- REMOVE CLEAN FASTQ FILES ------------- ##

if ($rm_clean_data =~ /1/){					##<- REMOVE COMMENT
	system "rm 01-trimming/*.fastq\n";			##<- REMOVE COMMENT
}								##<- REMOVE COMMENT


# -------------- REMOVE MAPPED SAM FILES ------------- ##

if ($rm_mapped_data =~ /1/){					##<- REMOVE COMMENT
	system "rm 02-mapping/*.sam\n";				##<- REMOVE COMMENT
}								##<- REMOVE COMMENT




		##----------------------- Step 6: GENERATING MATRIX BASED ON CUTOFF -----------------------##




print "Step 6 - Matrix counts of sRNAs\n"; # HERE A PRINT OF STEP




# -------------- MAKING CUTOFF ------------- ##

if ($renamed !~ /yes/){

	system "perl $filter_count $input_file 03-shortcat/all.count $cutoff_reads > 03-shortcat/all_filter_cutoff_$cutoff_reads.count\n"; ##<- REMOVE COMMENT

} else {

	open ($fh_4,">","03-shortcat/all_filter_cutoff_$cutoff_reads.count");

	my @lines_cutoff = `perl $filter_count $input_file 03-shortcat/all.count $cutoff_reads`;
	chomp @lines_cutoff;

	my $head_cutoff = shift (@lines_cutoff);
	
	my $index_cutoff = 0;

	print $fh_4 "$head_cutoff\n";

	foreach my $each_line_cutoff (@lines_cutoff){
		$index_cutoff++;

		my @cols_cutoff = split ("\t", $each_line_cutoff);
		$cols_cutoff[3] = "SmallRNA_$index_cutoff";

		my $recover_line_cutoff = join ("\t", @cols_cutoff);

		print $fh_4 "$recover_line_cutoff\n";
	}
}




# -------------- REPORTS ------------- ##

my $number_sRNAs_cutoff = `wc -l 03-shortcat/all_filter_cutoff_$cutoff_reads.count | cut -f 1 | awk '{print \$1 - 1}'`;
chomp $number_sRNAs_cutoff;

my $min_length_sRNAs_cutoff = `cut -f 5 03-shortcat/all_filter_cutoff_$cutoff_reads.count | awk 'NR > 1' | sort -n | head -1`;
chomp $min_length_sRNAs_cutoff;

my $max_length_sRNAs_cutoff = `cut -f 5 03-shortcat/all_filter_cutoff_$cutoff_reads.count | awk 'NR > 1' | sort -n | tail -1`;
chomp $max_length_sRNAs_cutoff;

my $number_of_one_read_cutoff = `cut -f 7 03-shortcat/all_filter_cutoff_$cutoff_reads.count | awk 'NR > 1' | sort -n | uniq -c | awk '{if(\$2 == 1) print \$1}'`;
chomp $number_of_one_read_cutoff;

my $percent_of_one_read_cutoff = "0%";

if (defined $number_of_one_read_cutoff){
	$percent_of_one_read_cutoff = ceil (($number_of_one_read_cutoff * 100)/$number_sRNAs_cutoff);  # Here is the use of module (ceil from POSIX)
} else {
	$number_of_one_read_cutoff = 0;
}

open ($fh_5,">","03-shortcat/00-reports/z_shortcat_report_cutoff_$cutoff_reads.txt");

print $fh_5 "Total sRNAs assembled after cutoff ($cutoff_reads reads):\t$number_sRNAs_cutoff\n";
print $fh_5 "Considering Counts from all samples:\n\t$number_of_one_read_cutoff sRNAs were formed by only 1 Read ($percent_of_one_read_cutoff\%)\n";
print $fh_5 "The length of sRNAs varies between $min_length_sRNAs_cutoff - $max_length_sRNAs_cutoff\n";





		##----------------------- Optional Step: MAKING ANNOTATION -----------------------##

if ($annot_perform =~ /yes/){

	print "Optional Step - Annotation of assembled sRNAs\n"; # HERE A PRINT OF STEP

	if (!defined $gff_annot_1){

		print "\t\tNot GFF file give in the command!. You need to explicit the rute of GFF file in the -1 option.\n";

	} else {

# -------------- MAKING ANNOT VS GFF1 ------------- ##
		
		system "awk 'NR > 1' 03-shortcat/all_filter_cutoff_$cutoff_reads.count | cut -f 1-6 > 04-annotation/all_filter_cutoff_$cutoff_reads.bed\n";

		# -------- NO -r OPTION
		if (!defined $the_r_option){
			# -------- YES -s OPTION
			if ($the_s_option){
				system "perl bin/4_annot.pl -s -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_1 > 04-annotation/annotation_sRNAs_1_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_1_raw.tab > 04-annotation/annotation_sRNAs_1.tab";
				system "rm 04-annotation/annotation_sRNAs_1_raw.tab";
			# -------- NO -s OPTION
			} else {
				system "perl bin/4_annot.pl -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_1 > 04-annotation/annotation_sRNAs_1_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_1_raw.tab > 04-annotation/annotation_sRNAs_1.tab";
				system "rm 04-annotation/annotation_sRNAs_1_raw.tab";
			}
		# -------- YES -r OPTION
		} else {
			# -------- YES -s OPTION
			if ($the_s_option){
				system "perl bin/4_annot.pl -s -r -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_1 > 04-annotation/annotation_sRNAs_1_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_1_raw.tab > 04-annotation/annotation_sRNAs_1.tab";
				system "rm 04-annotation/annotation_sRNAs_1_raw.tab";
			# -------- NO -s OPTION
			} else {
				system "perl bin/4_annot.pl -r -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_1 > 04-annotation/annotation_sRNAs_1_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_1_raw.tab > 04-annotation/annotation_sRNAs_1.tab";
				system "rm 04-annotation/annotation_sRNAs_1_raw.tab";
			}
		}

# -------------- MAKING ANNOT VS GFF2 ------------- ##

		if (defined $gff_annot_2){
			# -------- NO -r OPTION
			if (!defined $the_r_option){
				# -------- YES -s OPTION
				if ($the_s_option){
					system "perl bin/4_annot.pl -s -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_2 > 04-annotation/annotation_sRNAs_2_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_2_raw.tab > 04-annotation/annotation_sRNAs_2.tab";
				system "rm 04-annotation/annotation_sRNAs_2_raw.tab";
				# -------- NO -s OPTION
				} else {
					system "perl bin/4_annot.pl -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_2 > 04-annotation/annotation_sRNAs_2_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_2_raw.tab > 04-annotation/annotation_sRNAs_2.tab";
				system "rm 04-annotation/annotation_sRNAs_2_raw.tab";
				}
			# -------- YES -r OPTION
			} else {
				# -------- YES -s OPTION
				if ($the_s_option){
					system "perl bin/4_annot.pl -s -r -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_2 > 04-annotation/annotation_sRNAs_2_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_2_raw.tab > 04-annotation/annotation_sRNAs_2.tab";
				system "rm 04-annotation/annotation_sRNAs_2_raw.tab";
				# -------- NO -s OPTION
				} else {
					system "perl bin/4_annot.pl -r -f $the_f_option 04-annotation/all_filter_cutoff_$cutoff_reads.bed $gff_annot_2 > 04-annotation/annotation_sRNAs_2_raw.tab\n";
				system "perl $parse_annot 04-annotation/annotation_sRNAs_2_raw.tab > 04-annotation/annotation_sRNAs_2.tab";
				system "rm 04-annotation/annotation_sRNAs_2_raw.tab";
				}
			}
		} else {
			print "\t\tNot GFF2 file for additional annotation specified (-2 option). Perfomed annotation against only one GFF.\n";
		}

		system "rm 04-annotation/all_filter_cutoff_$cutoff_reads.bed\n"; ##<- REMOVE COMMENT
	}



} else {

	print "\nSelected NOT perform annotation of assembled sRNAs. Skipping...\n";

}




		##----------------------- Step 7: DIFFERENTIAL EXPRESSION -----------------------##




print "Step 7 - Differential expression analysis\n"; # HERE A PRINT OF STEP




# -------------- FILES TO DESEQ2 ------------- ##

## - COUNTS DATA
system "cut -f 4,8- 03-shortcat/all_filter_cutoff_$cutoff_reads.count | sed 's/Contig/gene_id/g' > 05-DiffExpression/all_filter_cutoff_$cutoff_reads\_toDESEQ2.tab";

## - CONDITIONS TAB FILE
system "cut -f 2 $input_file | awk '{print \$1 \"\\t\" \$1}' | awk '{gsub(/[0-9]\+/,\"\",\$2); print \$1 \"\\t\" \$2}' | awk ' BEGIN {print \"sample\\tcondition\\ttype\"}{x=\"\\t\"; print \$1 x \$2 x \"single\"}' > 05-DiffExpression/all_filter_cutoff_$cutoff_reads\_CONDITIONS.tab";

## - LENGTHS sRNAs
system "cut -f 4,5 03-shortcat/all_filter_cutoff_$cutoff_reads.count | awk 'NR > 1' | awk ' BEGIN {print \"gene_id\\tLength\"}{print \$0}' > 05-DiffExpression/z_sRNAs_length.tab";


## - CREATING R SCRIPTS
system "perl $modify_R bin/z_sorfde.txt all_filter_cutoff_$cutoff_reads\_toDESEQ2.tab all_filter_cutoff_$cutoff_reads\_CONDITIONS.tab";




# -------------- RUN DIFF EXPRESSION ------------- ##

chdir "05-DiffExpression";		##<- REMOVE COMMENT
system "Rscript No_x.R";		##<- REMOVE COMMENT
system "Rscript No_1.R";		##<- REMOVE COMMENT
system "Rscript No_2.R";		##<- REMOVE COMMENT
chdir "..";				##<- REMOVE COMMENT




# -------------- REMOVE FILES ------------- ##

#system "rm 05-DiffExpression/No_x.R";						##<- REMOVE COMMENT
#system "rm 05-DiffExpression/No_1.R";						##<- REMOVE COMMENT
#system "rm 05-DiffExpression/No_2.R";						##<- REMOVE COMMENT
#system "rm 05-DiffExpression/all_filter_cutoff_$cutoff_reads\_CONDITIONS.tab";	##<- REMOVE COMMENT
#system "rm 05-DiffExpression/all_filter_cutoff_$cutoff_reads\_toDESEQ2.tab";	##<- REMOVE COMMENT
#system "rm 05-DiffExpression/z_sRNAs_length.tab";				##<- REMOVE COMMENT





		##----------------------- Step 8: MAKING FINAL TABLES FILES -----------------------##




print "Step 8 (final)- Generating tables\n"; # HERE A PRINT OF STEP




# -------------- PASSING CSV NORMALIZED COUNTS TO TAB FILE------------- ##

system "sed 's/,/\t/g' 05-DiffExpression/FPKM_normalized_sRNAs.csv | sed 's/\"//g' | sed 's/\\./,/g' > 05-DiffExpression/FPKM_normalized_sRNAs.tab"; 	##<- REMOVE COMMENT

system "sed 's/,/\t/g' 05-DiffExpression/DESEQ2_normalized_sRNAs.csv | sed 's/\"//g' | sed 's/\\./,/g' > 05-DiffExpression/DESEQ2_normalized_sRNAs.tab"; 	##<- REMOVE COMMENT

system "rm 05-DiffExpression/FPKM_normalized_sRNAs.csv"; 	##<- REMOVE COMMENT
system "rm 05-DiffExpression/DESEQ2_normalized_sRNAs.csv"; 	##<- REMOVE COMMENT




# -------------- PASSING CSV TO TAB AND MERGELIST------------- ##

my @diff_exp_files = `ls 05-DiffExpression/*.csv`;
chomp @diff_exp_files;

foreach my $each_diff_exp_file (@diff_exp_files){

	my $name_out = `ls $each_diff_exp_file | awk -F "/" '{print \$NF}' | sed 's/\.csv//g'`;
	chomp $name_out;

# - Pass CSV to TAB
	system "sed 's/,/\t/g' $each_diff_exp_file | sed 's/\"//g' | awk 'NR > 1' | awk ' BEGIN {print \"ID\\tbaseMean($name_out)\\tlog2FoldChange\\tlfcSE\\tstat\\tpvalue\\tpadj\"}{print \$0}' | sed 's/\\./,/g' > 06-FinalTables/$name_out\_DiffExp.tab";

}




# -------------- MAKING MERGELIST ------------- ##

system "cat  06-FinalTables/*_DiffExp.tab | cut -f 1 | sort -u | grep -v \"ID\" | awk ' BEGIN {print \"ID\"}{print \$0}' > 06-FinalTables/z_sRNAs_id.list";


# - Make mergelist

my @files_csv2tab = `ls 06-FinalTables/*_DiffExp.tab`;
chomp @files_csv2tab;

my $join_files_csv2tab = join (" | perl $merge_list - ", @files_csv2tab);

system "perl $merge_list 06-FinalTables/z_sRNAs_id.list $join_files_csv2tab > 06-FinalTables/Differential_Expression_results.tab";

system "rm 06-FinalTables/z_sRNAs_id.list";
system "rm 06-FinalTables/*_DiffExp.tab";




# -------------- ADD ANNOTATION INFORMATION (OPTIONAL) ------------- ##

if ($annot_perform =~ /yes/){

	system "cat 04-annotation/annotation_sRNAs* | grep -v \"Command used was\" | cut -f 1 | sort -u > 04-annotation/z_sRNAs.list";
	
	my $number_of_annot = `ls 04-annotation/annotation_sRNAs* | wc -l`;
	chomp $number_of_annot;

	if ($number_of_annot > 1){

		my @files_annot = `ls 04-annotation/annotation_sRNAs*`;
		chomp @files_annot;

		my $join_files_annot = join (" | perl $merge_list - ", @files_annot);
		
		system "perl $merge_list 04-annotation/z_sRNAs.list $join_files_annot | awk ' BEGIN {print \"ID\\tGFF1\\tGFF2\"}{print \$0}' > 06-FinalTables/Annot_table.tab\n";

	} else {

		my $one_file_annot = `ls 04-annotation/annotation_sRNAs*`;
		chomp $one_file_annot;

		system "grep -v \"Command used was\" $one_file_annot | awk ' BEGIN {print \"ID\\tGFF1\"}{print \$0}' > 06-FinalTables/Annot_table.tab\n";
	}

	system "perl $merge_list 06-FinalTables/Annot_table.tab 06-FinalTables/Differential_Expression_results.tab > 06-FinalTables/Differential_Expression_results_addANNOTATION.tab\n";

	system "rm 04-annotation/z_sRNAs.list\n"; 			##<- REMOVE COMMENT
	system "rm 06-FinalTables/Differential_Expression_results.tab"; ##<- REMOVE COMMENT
	system "rm 06-FinalTables/Annot_table.tab"; 			##<- REMOVE COMMENT

}






















## -t	Number of threads (Default: 1).

## -trimmo	Options for trimmomatic (Default: 5:5:4:30:16).
	## first numbers is LEADING
	## second numbers is TRAILING
	## third numbers is SLIDINGWINDOW first number (WINDOW)
	## fourth numbers is SLIDINGWINDOW second number (QUALITY OF WINDOW)
	## fifth numbers is MINLEN

## -bt2	Options for Bowtie2 (Default: 1:10)
	## first numbers is the allowed MISMATCHES
	## second numbers is the cutoff of MAX NUMBER OF ALIGMENTS

## -x	Rute of Bowtie2 Indexes.

## -shortcat Remove (or not) additional files generated by ShortCat (Default: yes)
	## The available options are "yes" and "no"
		## The option "no" leaves all files generated by Shortcat
		## The option "yes" leaves only the assembled sRNAs count file generated by Shortcat

## -rm	Select the files to be removed from the different steps (Default: 0:0:0)
	## The firts number can be 0 or 1
		## Selection of 0 NOT remove the ZIP files generated by FASTQC in "00-quallity/00-raw_data"
	## The second number can be 0 or 1
		## Selection of 0 NOT remove the FASTQ good generated by TRIMMOMATIC in "01-trimming"
	## The third number can be 0 or 1
		## Selection of 0 NOT remove the SAM files generated by BOWTIE in "02-mapping"

## -cr	Select the cutoff of reads for filter the matrix counts generated by ShortCat (Default: 5).

## -annot	Perform or not annotation based on GFF file (Default: no).
##		NOTE that "-annot" run with additional options. These are:

		## -gff1	Annotation file 1 in GFF format.		
		## -gff2	Annotarion file 2 in GFF format (Optional).
		## -f		Overlapping of sRNAs with GFF features (Default: 0.50, that is 50% of overlap).
		## -r		Require that the fraction overlap be reciprocal for sRNAs and features in GFF. 



















